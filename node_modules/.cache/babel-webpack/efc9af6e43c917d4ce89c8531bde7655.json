{"ast":null,"code":"import _asyncToGenerator from \"/Users/kieran/development/Website/kierans_website/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\n\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n// Note, this module is not included in package exports so that it's private to\n// our first-party directives. If it ends up being useful, we can open it up and\n// export it.\n\n/**\n * Helper to iterate an AsyncIterable in its own closure.\n * @param iterable The iterable to iterate\n * @param callback The callback to call for each value. If the callback returns\n * `false`, the loop will be broken.\n */\nexport const forAwaitOf = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (iterable, callback) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(iterable), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const v = _value;\n\n        if ((yield callback(v)) === false) {\n          return;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          yield _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n\n  return function forAwaitOf(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Holds a reference to an instance that can be disconnected and reconnected,\n * so that a closure over the ref (e.g. in a then function to a promise) does\n * not strongly hold a ref to the instance. Approximates a WeakRef but must\n * be manually connected & disconnected to the backing instance.\n */\n\nexport class PseudoWeakRef {\n  constructor(ref) {\n    this._ref = ref;\n  }\n  /**\n   * Disassociates the ref with the backing instance.\n   */\n\n\n  disconnect() {\n    this._ref = undefined;\n  }\n  /**\n   * Reassociates the ref with the backing instance.\n   */\n\n\n  reconnect(ref) {\n    this._ref = ref;\n  }\n  /**\n   * Retrieves the backing instance (will be undefined when disconnected)\n   */\n\n\n  deref() {\n    return this._ref;\n  }\n\n}\n/**\n * A helper to pause and resume waiting on a condition in an async function\n */\n\nexport class Pauser {\n  constructor() {\n    this._promise = undefined;\n    this._resolve = undefined;\n  }\n  /**\n   * When paused, returns a promise to be awaited; when unpaused, returns\n   * undefined. Note that in the microtask between the pauser being resumed\n   * an an await of this promise resolving, the pauser could be paused again,\n   * hence callers should check the promise in a loop when awaiting.\n   * @returns A promise to be awaited when paused or undefined\n   */\n\n\n  get() {\n    return this._promise;\n  }\n  /**\n   * Creates a promise to be awaited\n   */\n\n\n  pause() {\n    var _a;\n\n    (_a = this._promise) !== null && _a !== void 0 ? _a : this._promise = new Promise(resolve => this._resolve = resolve);\n  }\n  /**\n   * Resolves the promise which may be awaited\n   */\n\n\n  resume() {\n    var _a;\n\n    (_a = this._resolve) === null || _a === void 0 ? void 0 : _a.call(this);\n    this._promise = this._resolve = undefined;\n  }\n\n}","map":{"version":3,"sources":["/Users/kieran/development/Website/kierans_website/node_modules/lit-html/development/directives/private-async-helpers.js"],"names":["forAwaitOf","iterable","callback","v","PseudoWeakRef","constructor","ref","_ref","disconnect","undefined","reconnect","deref","Pauser","_promise","_resolve","get","pause","_a","Promise","resolve","resume","call"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,UAAU;AAAA,+BAAG,WAAOC,QAAP,EAAiBC,QAAjB,EAA8B;AAAA;AAAA;;AAAA;;AAAA;AACpD,0CAAsBD,QAAtB,oLAAgC;AAAA,cAAfE,CAAe;;AAC5B,YAAI,OAAOD,QAAQ,CAACC,CAAD,CAAf,MAAwB,KAA5B,EAAmC;AAC/B;AACH;AACJ;AALmD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMvD,GANsB;;AAAA,kBAAVH,UAAU;AAAA;AAAA;AAAA,GAAhB;AAOP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMI,aAAN,CAAoB;AACvBC,EAAAA,WAAW,CAACC,GAAD,EAAM;AACb,SAAKC,IAAL,GAAYD,GAAZ;AACH;AACD;AACJ;AACA;;;AACIE,EAAAA,UAAU,GAAG;AACT,SAAKD,IAAL,GAAYE,SAAZ;AACH;AACD;AACJ;AACA;;;AACIC,EAAAA,SAAS,CAACJ,GAAD,EAAM;AACX,SAAKC,IAAL,GAAYD,GAAZ;AACH;AACD;AACJ;AACA;;;AACIK,EAAAA,KAAK,GAAG;AACJ,WAAO,KAAKJ,IAAZ;AACH;;AArBsB;AAuB3B;AACA;AACA;;AACA,OAAO,MAAMK,MAAN,CAAa;AAChBP,EAAAA,WAAW,GAAG;AACV,SAAKQ,QAAL,GAAgBJ,SAAhB;AACA,SAAKK,QAAL,GAAgBL,SAAhB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIM,EAAAA,GAAG,GAAG;AACF,WAAO,KAAKF,QAAZ;AACH;AACD;AACJ;AACA;;;AACIG,EAAAA,KAAK,GAAG;AACJ,QAAIC,EAAJ;;AACA,KAACA,EAAE,GAAG,KAAKJ,QAAX,MAAyB,IAAzB,IAAiCI,EAAE,KAAK,KAAK,CAA7C,GAAiDA,EAAjD,GAAuD,KAAKJ,QAAL,GAAgB,IAAIK,OAAJ,CAAaC,OAAD,IAAc,KAAKL,QAAL,GAAgBK,OAA1C,CAAvE;AACH;AACD;AACJ;AACA;;;AACIC,EAAAA,MAAM,GAAG;AACL,QAAIH,EAAJ;;AACA,KAACA,EAAE,GAAG,KAAKH,QAAX,MAAyB,IAAzB,IAAiCG,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAACI,IAAH,CAAQ,IAAR,CAA1D;AACA,SAAKR,QAAL,GAAgB,KAAKC,QAAL,GAAgBL,SAAhC;AACH;;AA7Be","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n// Note, this module is not included in package exports so that it's private to\n// our first-party directives. If it ends up being useful, we can open it up and\n// export it.\n/**\n * Helper to iterate an AsyncIterable in its own closure.\n * @param iterable The iterable to iterate\n * @param callback The callback to call for each value. If the callback returns\n * `false`, the loop will be broken.\n */\nexport const forAwaitOf = async (iterable, callback) => {\n    for await (const v of iterable) {\n        if ((await callback(v)) === false) {\n            return;\n        }\n    }\n};\n/**\n * Holds a reference to an instance that can be disconnected and reconnected,\n * so that a closure over the ref (e.g. in a then function to a promise) does\n * not strongly hold a ref to the instance. Approximates a WeakRef but must\n * be manually connected & disconnected to the backing instance.\n */\nexport class PseudoWeakRef {\n    constructor(ref) {\n        this._ref = ref;\n    }\n    /**\n     * Disassociates the ref with the backing instance.\n     */\n    disconnect() {\n        this._ref = undefined;\n    }\n    /**\n     * Reassociates the ref with the backing instance.\n     */\n    reconnect(ref) {\n        this._ref = ref;\n    }\n    /**\n     * Retrieves the backing instance (will be undefined when disconnected)\n     */\n    deref() {\n        return this._ref;\n    }\n}\n/**\n * A helper to pause and resume waiting on a condition in an async function\n */\nexport class Pauser {\n    constructor() {\n        this._promise = undefined;\n        this._resolve = undefined;\n    }\n    /**\n     * When paused, returns a promise to be awaited; when unpaused, returns\n     * undefined. Note that in the microtask between the pauser being resumed\n     * an an await of this promise resolving, the pauser could be paused again,\n     * hence callers should check the promise in a loop when awaiting.\n     * @returns A promise to be awaited when paused or undefined\n     */\n    get() {\n        return this._promise;\n    }\n    /**\n     * Creates a promise to be awaited\n     */\n    pause() {\n        var _a;\n        (_a = this._promise) !== null && _a !== void 0 ? _a : (this._promise = new Promise((resolve) => (this._resolve = resolve)));\n    }\n    /**\n     * Resolves the promise which may be awaited\n     */\n    resume() {\n        var _a;\n        (_a = this._resolve) === null || _a === void 0 ? void 0 : _a.call(this);\n        this._promise = this._resolve = undefined;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}