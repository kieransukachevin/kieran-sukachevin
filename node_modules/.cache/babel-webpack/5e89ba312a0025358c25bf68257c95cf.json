{"ast":null,"code":"import _asyncToGenerator from \"/Users/kieran/development/Website/kierans_website/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n/**\n * MutationController is a ReactiveController that integrates a MutationObserver\n * with a ReactiveControllerHost's reactive update lifecycle. This is typically\n * a ReactiveElement or LitElement. MutationObservers can be used to detect\n * arbitrary changes to DOM, including nodes being added and remove and\n * attributes changing.\n *\n * The controller can specify a `target` element to observe and the\n * configuration options to pass to the MutationObserver. The `observe`\n * method can be called to observe additional elements.\n *\n * When a change is detected, the controller's given `callback` function is\n * used to process the result into a value which is stored on the controller.\n * The controller's `value` is usable during the host's update cycle.\n */\nexport class MutationController {\n  constructor(host, {\n    target,\n    config,\n    callback,\n    skipInitial\n  }) {\n    this._targets = new Set();\n    this._skipInitial = false;\n    /**\n     * Flag used to help manage calling the `callback` when observe is called\n     * in addition to when a mutation occurs. This is done to help setup initial\n     * state and is performed async by requesting a host update and calling\n     * `handleChanges` once by checking and then resetting this flag.\n     */\n    this._unobservedUpdate = false;\n    this._host = host;\n    // Target defaults to `host` unless explicitly `null`.\n    if (target !== null) {\n      this._targets.add(target !== null && target !== void 0 ? target : host);\n    }\n    this._config = config;\n    this._skipInitial = skipInitial !== null && skipInitial !== void 0 ? skipInitial : this._skipInitial;\n    this.callback = callback;\n    // Check browser support.\n    if (!window.MutationObserver) {\n      console.warn(`MutationController error: browser does not support MutationObserver.`);\n      return;\n    }\n    this._observer = new MutationObserver(records => {\n      this.handleChanges(records);\n      this._host.requestUpdate();\n    });\n    host.addController(this);\n  }\n  /**\n   * Process the observer's changes with the controller's `callback`\n   * function to produce a result stored in the `value` property.\n   */\n  handleChanges(records) {\n    var _a;\n    this.value = (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, records, this._observer);\n  }\n  hostConnected() {\n    for (const target of this._targets) {\n      this.observe(target);\n    }\n  }\n  hostDisconnected() {\n    this.disconnect();\n  }\n  hostUpdated() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Eagerly deliver any changes that happened during update.\n      // And handle initial state as a set of 0 changes. This helps setup initial\n      // state and promotes UI = f(state) since ideally the callback does not\n      // rely on changes.\n      const pendingRecords = _this._observer.takeRecords();\n      if (pendingRecords.length || !_this._skipInitial && _this._unobservedUpdate) {\n        _this.handleChanges(pendingRecords);\n      }\n      _this._unobservedUpdate = false;\n    })();\n  }\n  /**\n   * Observe the target element. The controller's `target` is automatically\n   * observed when the host connects.\n   * @param target Element to observe\n   */\n  observe(target) {\n    this._targets.add(target);\n    this._observer.observe(target, this._config);\n    this._unobservedUpdate = true;\n    this._host.requestUpdate();\n  }\n  /**\n   * Disconnects the observer. This is done automatically when the host\n   * disconnects.\n   */\n  disconnect() {\n    this._observer.disconnect();\n  }\n}","map":{"version":3,"names":["MutationController","constructor","host","target","config","callback","skipInitial","_targets","Set","_skipInitial","_unobservedUpdate","_host","add","_config","window","MutationObserver","console","warn","_observer","records","handleChanges","requestUpdate","addController","_a","value","call","hostConnected","observe","hostDisconnected","disconnect","hostUpdated","pendingRecords","takeRecords","length"],"sources":["/Users/kieran/development/Website/kierans_website/node_modules/@lit-labs/observers/development/mutation_controller.js"],"sourcesContent":["/**\n * MutationController is a ReactiveController that integrates a MutationObserver\n * with a ReactiveControllerHost's reactive update lifecycle. This is typically\n * a ReactiveElement or LitElement. MutationObservers can be used to detect\n * arbitrary changes to DOM, including nodes being added and remove and\n * attributes changing.\n *\n * The controller can specify a `target` element to observe and the\n * configuration options to pass to the MutationObserver. The `observe`\n * method can be called to observe additional elements.\n *\n * When a change is detected, the controller's given `callback` function is\n * used to process the result into a value which is stored on the controller.\n * The controller's `value` is usable during the host's update cycle.\n */\nexport class MutationController {\n    constructor(host, { target, config, callback, skipInitial }) {\n        this._targets = new Set();\n        this._skipInitial = false;\n        /**\n         * Flag used to help manage calling the `callback` when observe is called\n         * in addition to when a mutation occurs. This is done to help setup initial\n         * state and is performed async by requesting a host update and calling\n         * `handleChanges` once by checking and then resetting this flag.\n         */\n        this._unobservedUpdate = false;\n        this._host = host;\n        // Target defaults to `host` unless explicitly `null`.\n        if (target !== null) {\n            this._targets.add(target !== null && target !== void 0 ? target : host);\n        }\n        this._config = config;\n        this._skipInitial = skipInitial !== null && skipInitial !== void 0 ? skipInitial : this._skipInitial;\n        this.callback = callback;\n        // Check browser support.\n        if (!window.MutationObserver) {\n            console.warn(`MutationController error: browser does not support MutationObserver.`);\n            return;\n        }\n        this._observer = new MutationObserver((records) => {\n            this.handleChanges(records);\n            this._host.requestUpdate();\n        });\n        host.addController(this);\n    }\n    /**\n     * Process the observer's changes with the controller's `callback`\n     * function to produce a result stored in the `value` property.\n     */\n    handleChanges(records) {\n        var _a;\n        this.value = (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, records, this._observer);\n    }\n    hostConnected() {\n        for (const target of this._targets) {\n            this.observe(target);\n        }\n    }\n    hostDisconnected() {\n        this.disconnect();\n    }\n    async hostUpdated() {\n        // Eagerly deliver any changes that happened during update.\n        // And handle initial state as a set of 0 changes. This helps setup initial\n        // state and promotes UI = f(state) since ideally the callback does not\n        // rely on changes.\n        const pendingRecords = this._observer.takeRecords();\n        if (pendingRecords.length ||\n            (!this._skipInitial && this._unobservedUpdate)) {\n            this.handleChanges(pendingRecords);\n        }\n        this._unobservedUpdate = false;\n    }\n    /**\n     * Observe the target element. The controller's `target` is automatically\n     * observed when the host connects.\n     * @param target Element to observe\n     */\n    observe(target) {\n        this._targets.add(target);\n        this._observer.observe(target, this._config);\n        this._unobservedUpdate = true;\n        this._host.requestUpdate();\n    }\n    /**\n     * Disconnects the observer. This is done automatically when the host\n     * disconnects.\n     */\n    disconnect() {\n        this._observer.disconnect();\n    }\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,kBAAkB,CAAC;EAC5BC,WAAW,CAACC,IAAI,EAAE;IAAEC,MAAM;IAAEC,MAAM;IAAEC,QAAQ;IAAEC;EAAY,CAAC,EAAE;IACzD,IAAI,CAACC,QAAQ,GAAG,IAAIC,GAAG,EAAE;IACzB,IAAI,CAACC,YAAY,GAAG,KAAK;IACzB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAACC,KAAK,GAAGT,IAAI;IACjB;IACA,IAAIC,MAAM,KAAK,IAAI,EAAE;MACjB,IAAI,CAACI,QAAQ,CAACK,GAAG,CAACT,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAGA,MAAM,GAAGD,IAAI,CAAC;IAC3E;IACA,IAAI,CAACW,OAAO,GAAGT,MAAM;IACrB,IAAI,CAACK,YAAY,GAAGH,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAGA,WAAW,GAAG,IAAI,CAACG,YAAY;IACpG,IAAI,CAACJ,QAAQ,GAAGA,QAAQ;IACxB;IACA,IAAI,CAACS,MAAM,CAACC,gBAAgB,EAAE;MAC1BC,OAAO,CAACC,IAAI,CAAE,sEAAqE,CAAC;MACpF;IACJ;IACA,IAAI,CAACC,SAAS,GAAG,IAAIH,gBAAgB,CAAEI,OAAO,IAAK;MAC/C,IAAI,CAACC,aAAa,CAACD,OAAO,CAAC;MAC3B,IAAI,CAACR,KAAK,CAACU,aAAa,EAAE;IAC9B,CAAC,CAAC;IACFnB,IAAI,CAACoB,aAAa,CAAC,IAAI,CAAC;EAC5B;EACA;AACJ;AACA;AACA;EACIF,aAAa,CAACD,OAAO,EAAE;IACnB,IAAII,EAAE;IACN,IAAI,CAACC,KAAK,GAAG,CAACD,EAAE,GAAG,IAAI,CAAClB,QAAQ,MAAM,IAAI,IAAIkB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,IAAI,CAAC,IAAI,EAAEN,OAAO,EAAE,IAAI,CAACD,SAAS,CAAC;EACjH;EACAQ,aAAa,GAAG;IACZ,KAAK,MAAMvB,MAAM,IAAI,IAAI,CAACI,QAAQ,EAAE;MAChC,IAAI,CAACoB,OAAO,CAACxB,MAAM,CAAC;IACxB;EACJ;EACAyB,gBAAgB,GAAG;IACf,IAAI,CAACC,UAAU,EAAE;EACrB;EACMC,WAAW,GAAG;IAAA;IAAA;MAChB;MACA;MACA;MACA;MACA,MAAMC,cAAc,GAAG,KAAI,CAACb,SAAS,CAACc,WAAW,EAAE;MACnD,IAAID,cAAc,CAACE,MAAM,IACpB,CAAC,KAAI,CAACxB,YAAY,IAAI,KAAI,CAACC,iBAAkB,EAAE;QAChD,KAAI,CAACU,aAAa,CAACW,cAAc,CAAC;MACtC;MACA,KAAI,CAACrB,iBAAiB,GAAG,KAAK;IAAC;EACnC;EACA;AACJ;AACA;AACA;AACA;EACIiB,OAAO,CAACxB,MAAM,EAAE;IACZ,IAAI,CAACI,QAAQ,CAACK,GAAG,CAACT,MAAM,CAAC;IACzB,IAAI,CAACe,SAAS,CAACS,OAAO,CAACxB,MAAM,EAAE,IAAI,CAACU,OAAO,CAAC;IAC5C,IAAI,CAACH,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACC,KAAK,CAACU,aAAa,EAAE;EAC9B;EACA;AACJ;AACA;AACA;EACIQ,UAAU,GAAG;IACT,IAAI,CAACX,SAAS,CAACW,UAAU,EAAE;EAC/B;AACJ"},"metadata":{},"sourceType":"module"}