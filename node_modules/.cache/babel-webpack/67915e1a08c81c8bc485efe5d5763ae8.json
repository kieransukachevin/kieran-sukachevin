{"ast":null,"code":"import _asyncToGenerator from \"/Users/kieran/development/Website/kierans_website/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * MutationController is a ReactiveController that integrates a MutationObserver\n * with a ReactiveControllerHost's reactive update lifecycle. This is typically\n * a ReactiveElement or LitElement. MutationObservers can be used to detect\n * arbitrary changes to DOM, including nodes being added and remove and\n * attributes changing.\n *\n * The controller can specify a `target` element to observe and the\n * configuration options to pass to the MutationObserver. The `observe`\n * method can be called to observe additional elements.\n *\n * When a change is detected, the controller's given `callback` function is\n * used to process the result into a value which is stored on the controller.\n * The controller's `value` is usable during the host's update cycle.\n */\nexport class MutationController {\n  constructor(host, {\n    target,\n    config,\n    callback,\n    skipInitial\n  }) {\n    this._targets = new Set();\n    this._skipInitial = false;\n    /**\n     * Flag used to help manage calling the `callback` when observe is called\n     * in addition to when a mutation occurs. This is done to help setup initial\n     * state and is performed async by requesting a host update and calling\n     * `handleChanges` once by checking and then resetting this flag.\n     */\n\n    this._unobservedUpdate = false;\n    this._host = host; // Target defaults to `host` unless explicitly `null`.\n\n    if (target !== null) {\n      this._targets.add(target !== null && target !== void 0 ? target : host);\n    }\n\n    this._config = config;\n    this._skipInitial = skipInitial !== null && skipInitial !== void 0 ? skipInitial : this._skipInitial;\n    this.callback = callback; // Check browser support.\n\n    if (!window.MutationObserver) {\n      console.warn(`MutationController error: browser does not support MutationObserver.`);\n      return;\n    }\n\n    this._observer = new MutationObserver(records => {\n      this.handleChanges(records);\n\n      this._host.requestUpdate();\n    });\n    host.addController(this);\n  }\n  /**\n   * Process the observer's changes with the controller's `callback`\n   * function to produce a result stored in the `value` property.\n   */\n\n\n  handleChanges(records) {\n    var _a;\n\n    this.value = (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, records, this._observer);\n  }\n\n  hostConnected() {\n    for (const target of this._targets) {\n      this.observe(target);\n    }\n  }\n\n  hostDisconnected() {\n    this.disconnect();\n  }\n\n  hostUpdated() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // Eagerly deliver any changes that happened during update.\n      // And handle initial state as a set of 0 changes. This helps setup initial\n      // state and promotes UI = f(state) since ideally the callback does not\n      // rely on changes.\n      const pendingRecords = _this._observer.takeRecords();\n\n      if (pendingRecords.length || !_this._skipInitial && _this._unobservedUpdate) {\n        _this.handleChanges(pendingRecords);\n      }\n\n      _this._unobservedUpdate = false;\n    })();\n  }\n  /**\n   * Observe the target element. The controller's `target` is automatically\n   * observed when the host connects.\n   * @param target Element to observe\n   */\n\n\n  observe(target) {\n    this._targets.add(target);\n\n    this._observer.observe(target, this._config);\n\n    this._unobservedUpdate = true;\n\n    this._host.requestUpdate();\n  }\n  /**\n   * Disconnects the observer. This is done automatically when the host\n   * disconnects.\n   */\n\n\n  disconnect() {\n    this._observer.disconnect();\n  }\n\n}","map":{"version":3,"sources":["/Users/kieran/development/Website/kierans_website/node_modules/@lit-labs/observers/development/mutation_controller.js"],"names":["MutationController","constructor","host","target","config","callback","skipInitial","_targets","Set","_skipInitial","_unobservedUpdate","_host","add","_config","window","MutationObserver","console","warn","_observer","records","handleChanges","requestUpdate","addController","_a","value","call","hostConnected","observe","hostDisconnected","disconnect","hostUpdated","pendingRecords","takeRecords","length"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,kBAAN,CAAyB;AAC5BC,EAAAA,WAAW,CAACC,IAAD,EAAO;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,MAAV;AAAkBC,IAAAA,QAAlB;AAA4BC,IAAAA;AAA5B,GAAP,EAAkD;AACzD,SAAKC,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AACA,SAAKC,YAAL,GAAoB,KAApB;AACA;AACR;AACA;AACA;AACA;AACA;;AACQ,SAAKC,iBAAL,GAAyB,KAAzB;AACA,SAAKC,KAAL,GAAaT,IAAb,CAVyD,CAWzD;;AACA,QAAIC,MAAM,KAAK,IAAf,EAAqB;AACjB,WAAKI,QAAL,CAAcK,GAAd,CAAkBT,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuCA,MAAvC,GAAgDD,IAAlE;AACH;;AACD,SAAKW,OAAL,GAAeT,MAAf;AACA,SAAKK,YAAL,GAAoBH,WAAW,KAAK,IAAhB,IAAwBA,WAAW,KAAK,KAAK,CAA7C,GAAiDA,WAAjD,GAA+D,KAAKG,YAAxF;AACA,SAAKJ,QAAL,GAAgBA,QAAhB,CAjByD,CAkBzD;;AACA,QAAI,CAACS,MAAM,CAACC,gBAAZ,EAA8B;AAC1BC,MAAAA,OAAO,CAACC,IAAR,CAAc,sEAAd;AACA;AACH;;AACD,SAAKC,SAAL,GAAiB,IAAIH,gBAAJ,CAAsBI,OAAD,IAAa;AAC/C,WAAKC,aAAL,CAAmBD,OAAnB;;AACA,WAAKR,KAAL,CAAWU,aAAX;AACH,KAHgB,CAAjB;AAIAnB,IAAAA,IAAI,CAACoB,aAAL,CAAmB,IAAnB;AACH;AACD;AACJ;AACA;AACA;;;AACIF,EAAAA,aAAa,CAACD,OAAD,EAAU;AACnB,QAAII,EAAJ;;AACA,SAAKC,KAAL,GAAa,CAACD,EAAE,GAAG,KAAKlB,QAAX,MAAyB,IAAzB,IAAiCkB,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAACE,IAAH,CAAQ,IAAR,EAAcN,OAAd,EAAuB,KAAKD,SAA5B,CAAvE;AACH;;AACDQ,EAAAA,aAAa,GAAG;AACZ,SAAK,MAAMvB,MAAX,IAAqB,KAAKI,QAA1B,EAAoC;AAChC,WAAKoB,OAAL,CAAaxB,MAAb;AACH;AACJ;;AACDyB,EAAAA,gBAAgB,GAAG;AACf,SAAKC,UAAL;AACH;;AACKC,EAAAA,WAAW,GAAG;AAAA;;AAAA;AAChB;AACA;AACA;AACA;AACA,YAAMC,cAAc,GAAG,KAAI,CAACb,SAAL,CAAec,WAAf,EAAvB;;AACA,UAAID,cAAc,CAACE,MAAf,IACC,CAAC,KAAI,CAACxB,YAAN,IAAsB,KAAI,CAACC,iBADhC,EACoD;AAChD,QAAA,KAAI,CAACU,aAAL,CAAmBW,cAAnB;AACH;;AACD,MAAA,KAAI,CAACrB,iBAAL,GAAyB,KAAzB;AAVgB;AAWnB;AACD;AACJ;AACA;AACA;AACA;;;AACIiB,EAAAA,OAAO,CAACxB,MAAD,EAAS;AACZ,SAAKI,QAAL,CAAcK,GAAd,CAAkBT,MAAlB;;AACA,SAAKe,SAAL,CAAeS,OAAf,CAAuBxB,MAAvB,EAA+B,KAAKU,OAApC;;AACA,SAAKH,iBAAL,GAAyB,IAAzB;;AACA,SAAKC,KAAL,CAAWU,aAAX;AACH;AACD;AACJ;AACA;AACA;;;AACIQ,EAAAA,UAAU,GAAG;AACT,SAAKX,SAAL,CAAeW,UAAf;AACH;;AA3E2B","sourcesContent":["/**\n * MutationController is a ReactiveController that integrates a MutationObserver\n * with a ReactiveControllerHost's reactive update lifecycle. This is typically\n * a ReactiveElement or LitElement. MutationObservers can be used to detect\n * arbitrary changes to DOM, including nodes being added and remove and\n * attributes changing.\n *\n * The controller can specify a `target` element to observe and the\n * configuration options to pass to the MutationObserver. The `observe`\n * method can be called to observe additional elements.\n *\n * When a change is detected, the controller's given `callback` function is\n * used to process the result into a value which is stored on the controller.\n * The controller's `value` is usable during the host's update cycle.\n */\nexport class MutationController {\n    constructor(host, { target, config, callback, skipInitial }) {\n        this._targets = new Set();\n        this._skipInitial = false;\n        /**\n         * Flag used to help manage calling the `callback` when observe is called\n         * in addition to when a mutation occurs. This is done to help setup initial\n         * state and is performed async by requesting a host update and calling\n         * `handleChanges` once by checking and then resetting this flag.\n         */\n        this._unobservedUpdate = false;\n        this._host = host;\n        // Target defaults to `host` unless explicitly `null`.\n        if (target !== null) {\n            this._targets.add(target !== null && target !== void 0 ? target : host);\n        }\n        this._config = config;\n        this._skipInitial = skipInitial !== null && skipInitial !== void 0 ? skipInitial : this._skipInitial;\n        this.callback = callback;\n        // Check browser support.\n        if (!window.MutationObserver) {\n            console.warn(`MutationController error: browser does not support MutationObserver.`);\n            return;\n        }\n        this._observer = new MutationObserver((records) => {\n            this.handleChanges(records);\n            this._host.requestUpdate();\n        });\n        host.addController(this);\n    }\n    /**\n     * Process the observer's changes with the controller's `callback`\n     * function to produce a result stored in the `value` property.\n     */\n    handleChanges(records) {\n        var _a;\n        this.value = (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, records, this._observer);\n    }\n    hostConnected() {\n        for (const target of this._targets) {\n            this.observe(target);\n        }\n    }\n    hostDisconnected() {\n        this.disconnect();\n    }\n    async hostUpdated() {\n        // Eagerly deliver any changes that happened during update.\n        // And handle initial state as a set of 0 changes. This helps setup initial\n        // state and promotes UI = f(state) since ideally the callback does not\n        // rely on changes.\n        const pendingRecords = this._observer.takeRecords();\n        if (pendingRecords.length ||\n            (!this._skipInitial && this._unobservedUpdate)) {\n            this.handleChanges(pendingRecords);\n        }\n        this._unobservedUpdate = false;\n    }\n    /**\n     * Observe the target element. The controller's `target` is automatically\n     * observed when the host connects.\n     * @param target Element to observe\n     */\n    observe(target) {\n        this._targets.add(target);\n        this._observer.observe(target, this._config);\n        this._unobservedUpdate = true;\n        this._host.requestUpdate();\n    }\n    /**\n     * Disconnects the observer. This is done automatically when the host\n     * disconnects.\n     */\n    disconnect() {\n        this._observer.disconnect();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}